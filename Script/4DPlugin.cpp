/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Script
 #	author : miyako
 #	2018/06/20
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Script

		case 1 :
			Script_parse(pResult, pParams);
			break;

	}
}

#pragma mark MyActiveScriptSite

class MyActiveScriptSite :
public IActiveScriptSite,
public IActiveScriptSiteWindow {
	private:
	ULONG m_cRefCount; // Reference count
	HWND m_hWnd;
	public:

	MyActiveScriptSite::MyActiveScriptSite() : m_cRefCount(1), m_hWnd(NULL) {}
	MyActiveScriptSite::~MyActiveScriptSite() {}
	
	// IUnknown methods...
	virtual HRESULT _stdcall QueryInterface(REFIID riid, void **ppvObject) {
		*ppvObject = NULL;
		return E_NOTIMPL;
	}
	
	virtual ULONG _stdcall AddRef(void) {
		return InterlockedIncrement(&m_cRefCount);
	}
	
	virtual ULONG _stdcall Release(void) {
		if (!InterlockedDecrement(&m_cRefCount))
		{
			delete this;
			return 0;
		}
		return m_cRefCount;
	}
	
	// IActiveScriptSite methods...
	virtual HRESULT _stdcall GetLCID(LCID *plcid) {
		return S_OK;
	}
	
	virtual HRESULT _stdcall GetItemInfo(LPCOLESTR pstrName,
																			 DWORD dwReturnMask,
																			 IUnknown **ppunkItem,
																			 ITypeInfo **ppti) {
		return TYPE_E_ELEMENTNOTFOUND;
	}
	
	virtual HRESULT __stdcall GetDocVersionString(BSTR *pbstrVersion) {
		*pbstrVersion = SysAllocString(L"1.0");
		return S_OK;
	}
	
	virtual HRESULT __stdcall OnScriptTerminate(const VARIANT *pvarResult,
																							const EXCEPINFO *pexcepInfo) {
		return S_OK;
	}
	
	virtual HRESULT __stdcall OnStateChange(SCRIPTSTATE ssScriptState) {
		return S_OK;
	}
	
	virtual HRESULT __stdcall OnScriptError(IActiveScriptError *pscriptError) {
		return S_OK;
	}
	
	virtual HRESULT __stdcall OnEnterScript(void) {
		return S_OK;
	}
	
	virtual HRESULT __stdcall OnLeaveScript(void) {
		return S_OK;
	}
	
	// IActiveScriptSiteWindow methods...
	virtual HRESULT __stdcall GetWindow(HWND *phWnd) {
		*phWnd = m_hWnd;
		return S_OK;
	}
	
	virtual HRESULT __stdcall EnableModeless(BOOL fEnable) {
		return S_OK;
	}
};

#pragma mark OleInitClass

class OleInitClass {
	
	public:
	OleInitClass() {
		OleInitialize(NULL);
	}
	
	~OleInitClass() {
		OleUninitialize();
	}
};

MyActiveScriptSite g_ActiveScriptSite;
OleInitClass g_OleInitClass;

// ------------------------------------ Script ------------------------------------

/* https://www.codeproject.com/Articles/14905/COM-in-plain-C-Part */

HRESULT getEngineGuid(LPCTSTR extension, GUID *guidBuffer)
{
	wchar_t   buffer[100];
	HKEY      hk;
	DWORD     size;
	HKEY      subKey;
	DWORD     type;
	
	// See if this file extension is associated
	// with an ActiveX script engine
	if (!RegOpenKeyEx(HKEY_CLASSES_ROOT, extension, 0,
										KEY_QUERY_VALUE|KEY_READ, &hk))
	{
		type = REG_SZ;
		size = sizeof(buffer);
		size = RegQueryValueEx(hk, 0, 0, &type,
													 (LPBYTE)&buffer[0], &size);
		RegCloseKey(hk);
		if (!size)
		{
			// The engine set an association.
			// We got the Language string in buffer[]. Now
			// we can use it to look up the engine's GUID
			
			// Open HKEY_CLASSES_ROOT\{LanguageName}
		again:   size = sizeof(buffer);
			if (!RegOpenKeyEx(HKEY_CLASSES_ROOT, (LPCTSTR)&buffer[0], 0,
												KEY_QUERY_VALUE|KEY_READ, &hk))
			{
				// Read the GUID (in string format)
				// into buffer[] by querying the value of CLSID
				if (!RegOpenKeyEx(hk, L"CLSID", 0,
													KEY_QUERY_VALUE|KEY_READ, &subKey))
				{
					size = RegQueryValueExW(subKey, 0, 0, &type,
																	(LPBYTE)&buffer[0], &size);
					RegCloseKey(subKey);
				}
				else if (extension)
				{
					// If an error, see if we have a "ScriptEngine"
					// key under here that contains
					// the real language name
					if (!RegOpenKeyEx(hk, L"ScriptEngine", 0,
														KEY_QUERY_VALUE|KEY_READ, &subKey))
					{
						size = RegQueryValueEx(subKey, 0, 0, &type,
																	 (LPBYTE)&buffer[0], &size);
						RegCloseKey(subKey);
						if (!size)
						{
							RegCloseKey(hk);
							extension = 0;
							goto again;
						}
					}
				}
			}
			
			RegCloseKey(hk);
			
			if (!size)
			{
				// Convert the GUID string to a GUID
				// and put it in caller's guidBuffer
				CLSIDFromString(&buffer[0], guidBuffer);
				return(size);
			}
		}
	}
	
	return(E_FAIL);
}

void Script_parse(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1_engine;
	C_TEXT Param2_script;
	C_TEXT returnValue;

	Param1_engine.fromParamAtIndex(pParams, 1);
	Param2_script.fromParamAtIndex(pParams, 2);

	wchar_t *engine = (wchar_t *)Param1_engine.getUTF16StringPtr();
	wchar_t *script = (wchar_t *)Param2_script.getUTF16StringPtr();
	
	HRESULT hr = S_OK;
	
	EXCEPINFO ei;
	ZeroMemory(&ei, sizeof(ei));
	
	VARIANT result;
	
	IActiveScript *pActiveScript;
	IActiveScriptParse *pActiveScriptParse;
	
	CLSID CLSID_Script;
	hr = CLSIDFromProgID(engine, &CLSID_Script);
	
	if (FAILED(hr))
	{
		hr = CLSIDFromString(engine, &CLSID_Script);
	}

	if (FAILED(hr))
	{
		hr = getEngineGuid(engine, &CLSID_Script);
	}

	if (SUCCEEDED(hr))
	{
		hr = CoCreateInstance(CLSID_Script,
													NULL,
													CLSCTX_ALL,
													IID_IActiveScript,
													(void **)&pActiveScript);	
		if (SUCCEEDED(hr))
		{
			hr = pActiveScript->SetScriptSite(&g_ActiveScriptSite);
			
			if (SUCCEEDED(hr))
			{
				hr = pActiveScript->QueryInterface(IID_IActiveScriptParse,
					(void **)&pActiveScriptParse);

				if (SUCCEEDED(hr))
				{
					hr = pActiveScriptParse->InitNew();
					
					if (SUCCEEDED(hr))
					{
						hr = pActiveScriptParse->ParseScriptText(script,
							0,
							0,
							0,
							0,
							0,
							SCRIPTTEXT_ISEXPRESSION | SCRIPTTEXT_ISVISIBLE,
							&result,
							&ei);
						if (SUCCEEDED(hr))
						{
							SYSTEMTIME systime;
							CUTF16String u16;
							CUTF8String u8;
							std::vector<char>buf(100);

							switch (result.vt)
							{
							case VT_EMPTY:
							case VT_NULL:
								break;

							case VT_R4:
								sprintf_s((char *)&buf[0], 100, "%f", result.fltVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;
							case VT_R8:
								sprintf_s((char *)&buf[0], 100, "%16.16lf", result.dblVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;

							case VT_I2:
								sprintf_s((char *)&buf[0], 100, "%d", result.intVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;
							case VT_UI2:
								sprintf_s((char *)&buf[0], 100, "%u", result.uintVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;

							case VT_INT:
							case VT_I4:
								sprintf_s((char *)&buf[0], 100, "%I32d", result.lVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;
							case VT_UINT:
							case VT_UI4:
								sprintf_s((char *)&buf[0], 100, "%I32u", result.ulVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;

							case VT_I8:
								sprintf_s((char *)&buf[0], 100, "%I64d", result.llVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;
							case VT_UI8:
								sprintf_s((char *)&buf[0], 100, "%I64u", result.ullVal);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;

							case VT_BSTR:
								u16 = (const PA_Unichar *)result.bstrVal;
								returnValue.setUTF16String(&u16);
								break;

							case VT_DATE:
								VariantTimeToSystemTime(result.date, &systime);
								sprintf_s((char *)&buf[0], 100, "%04u-%02u-%02uT%02d:%02d:%02d.%03d", 
									systime.wYear, 
									systime.wMonth, 
									systime.wDay,  
									systime.wHour, 
									systime.wMinute, 
									systime.wSecond,
									systime.wMilliseconds);
								u8 = (const uint8_t *)&buf[0];
								returnValue.setUTF8String(&u8);
								break;
							}

							pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
						}/* ParseScriptText */
						
					}/* InitNew */
					
					pActiveScriptParse->Release();
					pActiveScriptParse = NULL;
				}/* QueryInterface */
			}
			pActiveScript->Close();
			pActiveScript->Release();
			pActiveScript = NULL;
		}/* CoCreateInstance */

	}
	
	returnValue.setReturn(pResult);
}

